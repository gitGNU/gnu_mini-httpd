mod IO-STATE is
  protecting CONFIGURATION .

  sort IoState .
  ops ready blocked error : -> IoState [ctor] .

  op in  =_ : IoState -> Attribute [ctor] .
  op out =_ : IoState -> Attribute [ctor] .
endm

mod IO-BUFFER is
  protecting IO-STATE .
  protecting NAT .

  var BUF : Oid .

  op IoBuf  :       -> Cid [ctor] .
  op active :       -> IoState [ctor] .
  op ptr    : NzNat -> Oid [ctor] .

  rl [flushIOBuffer]
    :  < BUF : IoBuf | in = blocked, out = blocked >
    => < BUF : IoBuf | in = ready,   out = blocked >
    .
endm

mod IO-PEER is
  protecting IO-STATE .
  protecting NAT .

  var AS : AttributeSet .
  var SRC SINK : Oid .

  op socket   : NzNat       -> Oid [ctor] .
  op receive  : Oid         -> Msg .
  op received : Oid IoState -> Msg .
  op send     : Oid         -> Msg .
  op sent     : Oid IoState -> Msg .

  rl [endOfInput]      : receive(SRC) => received(SRC, error)   .
  rl [inputUnderflow]  : receive(SRC) => received(SRC, blocked) .
  rl [inputOverflow]   : receive(SRC) => received(SRC, ready)   .
  rl [outputUnderflow] : send(SINK)   => sent(SINK, ready)      .
  rl [outputOverflow]  : send(SINK)   => sent(SINK, blocked)    .
endm

mod IO-DRIVER is
  protecting IO-PEER .
  protecting IO-BUFFER .

  var AS : AttributeSet .
  var SRC SINK BUF : Oid .

  op init : -> Configuration .
  eq init = <>
    < ptr(34) : IoBuf | in = ready, out = blocked >
    driver(socket(5), socket(8), ptr(34))
    .

  op driver : Oid Oid Oid -> Msg [ctor] .

  rl [shutdown]
    :  < BUF : IoBuf | in = error, out = blocked >
       driver(SRC, SINK, BUF)
    => < BUF : IoBuf | in = error, out = error >
    .

  --- input

  rl [startRead]
    :  < BUF : IoBuf | in = ready, out = blocked >
       driver(SRC, SINK, BUF)
    => < BUF : IoBuf | in = active, out = blocked >
       driver(SRC, SINK, BUF)
       receive(SRC)
    .

  rl [handleEndOfInput]
    :  < BUF : IoBuf | in = active, AS >
       driver(SRC, SINK, BUF)
       received(SRC, error)
    => < BUF : IoBuf | in = error, AS >
       driver(SRC, SINK, BUF)
    .

  rl [handleInputOverflow]
    :  < BUF : IoBuf | in = active, out = blocked >
       driver(SRC, SINK, BUF)
       received(SRC, ready)
    => < BUF : IoBuf | in = blocked, out = active >
       driver(SRC, SINK, BUF)
       send(SINK)
    .

  rl [handleInputUnderflow]
    :  < BUF : IoBuf | in = active, out = blocked >
       driver(SRC, SINK, BUF)
       received(SRC, blocked)
    => < BUF : IoBuf | in = active, out = active >
       driver(SRC, SINK, BUF)
       receive(SRC)
       send(SINK)
    .

  --- output

  rl [handleOutputUnderflow]
    :  < BUF  : IoBuf | out = active, AS >
       driver(SRC, SINK, BUF)
       sent(SINK, blocked)
    => < BUF  : IoBuf | out = active, AS >
       driver(SRC, SINK, BUF)
       send(SINK)
    .

  rl [handleOutputOverflow]
    :  < BUF  : IoBuf | out = active, AS >
       driver(SRC, SINK, BUF)
       sent(SINK, ready)
    => < BUF  : IoBuf | out = blocked, AS >
       driver(SRC, SINK, BUF)
    .
endm
