fmod IO-BUFFER is
  including NAT .

  var GAP LEN SPC : Nat .
  var I : NzNat .

  sort Iobuf .

  op buf : Nat Nat Nat -> Iobuf [ctor] .
  eq buf(I, 0, SPC) = buf(0, 0, SPC + I) .

  var IOB : Iobuf .

  ops gap size space capacity : Iobuf -> Nat .
  eq gap(buf(GAP, LEN, SPC))    = GAP .
  eq size(buf(GAP, LEN, SPC))   = LEN .
  eq space(buf(GAP, LEN, SPC))  = SPC .
  eq capacity(IOB) = gap(IOB) + size(IOB) + space(IOB) .

  op append : Iobuf NzNat -> Iobuf .
  eq  append(buf(GAP, LEN, SPC), I)
    = buf(GAP, LEN + I, sd(SPC, I))
    .

  op consume : Iobuf NzNat -> Iobuf .
  eq  consume(buf(GAP, LEN, SPC), I)
    = buf(GAP + I, sd(LEN, I), SPC)
    .

  op flushGap : Iobuf -> Iobuf .
  eq  flushGap(buf(GAP, LEN, SPC))
    = buf(0, LEN, SPC + GAP)
    .

  op realloc  : Iobuf NzNat -> Iobuf .
  ceq realloc(buf(GAP, LEN, SPC), I)
    = buf(0, LEN, sd(LEN, I))   if I > LEN
    .

endfm

mod MAIN is
  protecting CONFIGURATION .
  protecting IO-BUFFER .
  protecting STRING .

  sort IoState .
  ops ready active blocked error : -> IoState [ctor] .

  op ptr    : NzNat -> Oid [ctor] .
  op socket : NzNat -> Oid [ctor] .

  var AS1 AS2 : AttributeSet .
  var SRC SINK BUF : Oid .
  var IOS : IoState .

  ops Peer IoBuf : -> Cid [ctor] .
  op in  =_ : IoState -> Attribute [ctor] .
  op out =_ : IoState -> Attribute [ctor] .

  op receive  : Oid Oid -> Msg .
  op received : Oid Oid -> Msg .
  op send     : Oid Oid -> Msg .
  op sent     : Oid Oid -> Msg .

  op init : -> Configuration .
  eq init = <>
    < socket(5) : Peer | in = ready >
    < socket(8) : Peer   | out = ready >
    < ptr(34)   : IoBuf  | in = ready, out = blocked >
    proxy(socket(5), socket(8), ptr(34))
    .

  op proxy : Oid Oid Oid -> Msg [ctor] .

  --- input

  rl [startRead]
    :  < SRC  : Peer | in = ready,  AS1 >
       < BUF  : IoBuf  | in = ready,  AS2 >
       proxy(SRC, SINK, BUF)
    => < SRC  : Peer | in = active, AS1 >
       < BUF  : IoBuf  | in = active, AS2 >
       receive(SRC, BUF)
       proxy(SRC, SINK, BUF)
    .

  rl [startAsyncRead]
    :  < SRC  : Peer | in = blocked, AS1 >
       < BUF  : IoBuf  | in = ready,   AS2 >
       proxy(SRC, SINK, BUF)
    => < SRC  : Peer | in = blocked, AS1 >
       < BUF  : IoBuf  | in = active,  AS2 >
       receive(SRC, BUF)
       proxy(SRC, SINK, BUF)
    .

  rl [receivePartial]
    :  < SRC  : Peer   | in = active,  AS1 >
       < BUF  : IoBuf  | in = active,  AS2 >
       receive(SRC, BUF)
    => < SRC  : Peer   | in = blocked, AS1 >
       < BUF  : IoBuf  | in = ready,   AS2 >
       received(SRC, BUF)
    .

  rl [receiveBuffer]
    :  < SRC  : Peer   | in = active,  AS1 >
       < BUF  : IoBuf  | in = active,  AS2 >
       receive(SRC, BUF)
    => < SRC  : Peer   | in = ready,   AS1 >
       < BUF  : IoBuf  | in = blocked, AS2 >
       received(SRC, BUF)
    .

  rl [handlePartialRead]
    :  < BUF  : IoBuf  | in = ready, AS1 >
       proxy(SRC, SINK, BUF)
       received(SRC, BUF)
    => < BUF  : IoBuf  | in = ready, AS1 >
       proxy(SRC, SINK, BUF)
    .

  rl [handleFullRead]
    :  < BUF  : IoBuf  | out = blocked, AS1 >
       proxy(SRC, SINK, BUF)
       received(SRC, BUF)
    => < BUF  : IoBuf  | out = ready,   AS1 >
       proxy(SRC, SINK, BUF)
    .

  --- output

  rl [startWrite]
    :  < SINK : Peer   | out = ready,  AS1 >
       < BUF  : IoBuf  | out = ready,  AS2 >
       proxy(SRC, SINK, BUF)
    => < SINK : Peer   | out = active, AS1 >
       < BUF  : IoBuf  | out = active, AS2 >
       proxy(SRC, SINK, BUF)
       send(SRC, BUF)
    .

  rl [startAsyncWrite]
    :  < SINK : Peer   | out = blocked, AS1 >
       < BUF  : IoBuf  | out = ready,   AS2 >
       proxy(SRC, SINK, BUF)
    => < SINK : Peer   | out = blocked, AS1 >
       < BUF  : IoBuf  | out = active,  AS2 >
       proxy(SRC, SINK, BUF)
       send(SRC, BUF)
    .

  rl [sendPartial]
    :  < SINK : Peer  | out = active,  AS1 >
       < BUF  : IoBuf | out = active,  AS2 >
       send(SRC, BUF)
    => < SINK : Peer  | out = blocked, AS1 >
       < BUF  : IoBuf | out = ready,   AS2 >
       sent(SRC, BUF)
    .

  rl [sendBuffer]
    :  < SINK : Peer  | out = active,  AS1 >
       < BUF  : IoBuf | out = active,  AS2 >
       send(SRC, BUF)
    => < SINK : Peer  | out = ready,   AS1 >
       < BUF  : IoBuf | out = blocked, AS2 >
       sent(SRC, BUF)
    .

  rl [handlePartialWrite]
    :  < BUF  : IoBuf  | out = ready, AS1 >
       proxy(SRC, SINK, BUF)
       sent(SRC, BUF)
    => < BUF  : IoBuf  | out = ready, AS1 >
       proxy(SRC, SINK, BUF)
    .

  rl [handleFullWrite]
    :  < BUF  : IoBuf  | in = blocked, out = blocked >
       proxy(SRC, SINK, BUF)
       sent(SRC, BUF)
    => < BUF  : IoBuf  | in = ready, out = blocked >
       proxy(SRC, SINK, BUF)
    .

***(
  rl [enqueueOutput]
    :  proxy(SRC, SINK, BUF)
       received(SRC, BUF) send(SRC, BUF)
    => proxy(SRC, SINK, BUF)
       send(SRC, BUF)
    .

  rl [consumeOutput]
    :  proxy(SRC, SINK, BUF)
       sent(SRC, BUF) send(SRC, BUF)
    => proxy(SRC, SINK, BUF)
       send(SRC, BUF)
    .
***)

  rl [flushOutput]
    :  < SRC  : Peer  | in = error, AS1 >
       < BUF  : IoBuf | in = IOS,   AS2 >
       received(SRC, BUF)
       proxy(SRC, SINK, BUF)
    => < SRC  : Peer  | in = error, AS1 >
       < BUF  : IoBuf | in = error, AS2 >
    .
***(
  crl [forceOutput]
    :  < SRC  : Peer  | in =
       < BUF  : IoBuf | in = error, out = IOS >
       proxy(SRC, SINK, BUF)
       sent(SRC, BUF)
    => < BUF  : IoBuf | in = error, out = blocked >
    if (IOS =/= blocked)
    .
***)
  rl [shutdown]
    :  < BUF  : IoBuf | in = error, out = blocked >
       proxy(SRC, SINK, BUF)
       sent(SRC, BUF)
    => < BUF  : IoBuf | in = error, out = error >
    .

  --- the world changes our i/o state at will

  rl [newInputArrived]
    :  < SRC  : Peer  | in = blocked, AS1 >
       receive(SRC, BUF)
    => < SRC  : Peer  | in = active,  AS1 >
       receive(SRC, BUF)
    .

  rl [endOfInput]
    :  < SRC  : Peer  | in = blocked, AS1 >
       receive(SRC, BUF)
    => < SRC  : Peer  | in = error,  AS1 >
       received(SRC, BUF)
    .

endm
