mod IO-STATE is
  protecting CONFIGURATION .

  sort IoState .
  ops ready blocked error : -> IoState [ctor] .

  op in  =_ : IoState -> Attribute [ctor] .
  op out =_ : IoState -> Attribute [ctor] .
endm

mod IO-BUFFER is
  protecting IO-STATE .
  protecting NAT .

  var BUF : Oid .

  op IoBuf  :       -> Cid [ctor] .
  op active :       -> IoState [ctor] .
  op ptr    : NzNat -> Oid [ctor] .

  rl [flushIOBuffer]
    :  < BUF : IoBuf | in = blocked, out = blocked >
    => < BUF : IoBuf | in = ready,   out = blocked >
    .
endm

mod IO-PEER is
  protecting IO-STATE .
  protecting NAT .

  var AS : AttributeSet .
  var SRC SINK : Oid .

  op Peer     :             -> Cid [ctor] .
  op socket   : NzNat       -> Oid [ctor] .
  op send     : Oid         -> Msg .
  op receive  : Oid         -> Msg .
  op sent     : Oid IoState -> Msg .
  op received : Oid IoState -> Msg .

  rl [inputArrived]
    :  < SRC  : Peer | in = blocked,  AS > receive(SRC)
    => < SRC  : Peer | in = ready,    AS > receive(SRC)
    .

  rl [endOfInput]
    :  < SRC  : Peer | in = ready,    AS > receive(SRC)
    => < SRC  : Peer | in = error,    AS > received(SRC, error)
    .

  rl [inputBufferUnderflow]
    :  < SRC  : Peer | in = ready,    AS > receive(SRC)
    => < SRC  : Peer | in = blocked,  AS > received(SRC, blocked)
    .

  rl [inputBufferOverflow]
    :  < SRC  : Peer | in = ready,    AS > receive(SRC)
    => < SRC  : Peer | in = ready,    AS > received(SRC, ready)
    .

  rl [outputWritten]
    :  < SINK : Peer | out = blocked, AS > send(SINK)
    => < SINK : Peer | out = ready,   AS > send(SINK)
    .

  rl [outputBufferUnderflow]
    :  < SINK : Peer | out = ready,   AS > send(SINK)
    => < SINK : Peer | out = ready,   AS > sent(SINK, ready)
    .

  rl [outputBufferOverflow]
    :  < SINK : Peer | out = ready,   AS > send(SINK)
    => < SINK : Peer | out = blocked, AS > sent(SINK, blocked)
    .
endm

mod IO-DRIVER is
  protecting IO-PEER .
  protecting IO-BUFFER .

  var AS : AttributeSet .
  var SRC SINK BUF : Oid .

  op init : -> Configuration .
  eq init = <>
    < socket(5) : Peer  | in = ready >
    < socket(8) : Peer  | out = ready >
    < ptr(34)   : IoBuf | in = ready, out = blocked >
    driver(socket(5), socket(8), ptr(34))
    .

  op driver : Oid Oid Oid -> Msg [ctor] .

  rl [shutdown]
    :  < BUF : IoBuf | in = error, out = blocked >
       driver(SRC, SINK, BUF)
    => < BUF : IoBuf | in = error, out = error >
    .

  --- input

  rl [startRead]
    :  < BUF : IoBuf | in = ready, AS >
       driver(SRC, SINK, BUF)
    => < BUF : IoBuf | in = active, AS >
       driver(SRC, SINK, BUF)
       receive(SRC)
    .

  rl [handleEndOfInput]
    :  < BUF : IoBuf | in = active, AS >
       driver(SRC, SINK, BUF)
       received(SRC, error)
    => < BUF : IoBuf | in = error, AS >
       driver(SRC, SINK, BUF)
    .

  rl [handleInputOverflow]
    :  < BUF : IoBuf | in = active, out = blocked >
       driver(SRC, SINK, BUF)
       received(SRC, ready)
    => < BUF : IoBuf | in = blocked, out = ready >
       driver(SRC, SINK, BUF)
    .

  rl [handleInputUnderflow]
    :  < BUF : IoBuf | in = active, out = blocked >
       driver(SRC, SINK, BUF)
       received(SRC, blocked)
    => < BUF : IoBuf | in = ready, out = ready >
       driver(SRC, SINK, BUF)
    .

  --- output

  rl [startWrite]
    :  < BUF  : IoBuf | out = ready, AS >
       driver(SRC, SINK, BUF)
    => < BUF  : IoBuf | out = active, AS >
       driver(SRC, SINK, BUF)
       send(SINK)
    .

  rl [handleOutputUnderflow]
    :  < BUF  : IoBuf | out = active, AS >
       driver(SRC, SINK, BUF)
       sent(SINK, blocked)
    => < BUF  : IoBuf | out = ready, AS >
       driver(SRC, SINK, BUF)
    .

  rl [handleOutputOverflow]
    :  < BUF  : IoBuf | out = active, AS >
       driver(SRC, SINK, BUF)
       sent(SINK, ready)
    => < BUF  : IoBuf | out = blocked, AS >
       driver(SRC, SINK, BUF)
    .
endm
